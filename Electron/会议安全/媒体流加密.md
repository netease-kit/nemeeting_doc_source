本文详细介绍如何在 Electron 框架上使用网易会议组件 NEMeetingKit 配置会议媒体流加密功能。为保障会议内容安全，NEMeetingKit 提供内置加密和自定义加密两种媒体流加密方案。

## 前提条件

开始本文操作前，请确保您已经完成了 [登录鉴权](https://doc.yunxin.163.com/meeting/guide/DUxNjQzNDA?platform=electron)。

## 方案一：内置加密配置

NEMeetingKit 提供内置的媒体流加密功能，您可通过 [`NEEncryptionConfig`](https://doc.yunxin.163.com/meetingkit/references/web/typedoc/Latest/zh/electron/types/NEEncryptionConfig.html) 进行配置，目前支持国密 SM4-ECB 算法。

:::note note
使用内置加密时，同一会议中的所有参会者必须配置相同的加解密密钥，否则将无法正常收发音视频。
:::

**示例代码**：

```TypeScript
import NEMeetingKit  from 'nemeeting-electron-sdk';

const neMeetingKit = NEMeetingKit.getInstance();
const meetingService = neMeetingKit.getMeetingService();

// 创建加密配置
const encryptionConfig = {
  encryptionMode: NEEncryptionMode.GMCryptoSM4ECB,
  encryptKey: "yourEncryptionKey",
};
// 设置加密配置到会议参数
const params = {
    displayName: '加密会议用户',
    encryptionConfig: encryptionConfig,
}
// 使用设置好的参数创建会议
meetingService.startMeeting(params).then(() => {
    // 创建会议成功
}).catch((error) => {
    // 创建会议失败
});
```

## 方案二：自定义加密实现

对于需要更高安全级别的场景，NEMeetingKit 支持通过底层依赖的 [音视频通话 2.0 NERTC SDK](https://doc.yunxin.163.com/nertc/concept?platform=client) 实现自定义加密。您可以使用自己的加密算法对音频帧和视频帧进行加解密处理。

### 注意事项

- 本文示例中的加解密算法仅作示范，生产环境中请使用安全的加密算法。
- 详细的自定义加密实现请参考 NERTC SDK [流媒体加密 Windows 版](https://doc.yunxin.163.com/nertc/guide/jgwNDMzNzY?platform=windows) 和 [流媒体加密 macOS 版](https://doc.yunxin.163.com/nertc/guide/DgzODM3ODU?platform=macOS) 。
- 同一会议中所有参会者必须使用相同的加解密算法和密钥。

### **实现步骤**

1.  **实现自定义加密逻辑的动态库**。

    ```cpp
    // "video_encrypt.h"
    #ifndef VIDEO_ENCRYPT_H
    #define VIDEO_ENCRYPT_H

    #ifdef __cplusplus
    extern "C" {
    #endif

    // 视频数据包结构
    struct NERtcMediaPacket {
        // 需要发送或接收的数据的缓存地址
        const unsigned char* buffer;
        // 需要发送或接收的数据的缓存大小
        long size;
    };

    // 导出函数声明
    #ifdef _WIN32
        #define EXPORT __declspec(dllexport)
    #else
        #define EXPORT __attribute__((visibility("default")))
    #endif
    /**
    * 就地加密视频数据（直接修改原数据）
    * @param packet 要加密的视频数据包
    * @return 0=成功, -1=失败
    */
    EXPORT int onSendAudioPacket(NERtcMediaPacket* packet);

    /**
    * 就地解密视频数据（直接修改原数据）
    * @param packet 要解密的视频数据包
    * @return 0=成功, -1=失败
    */
    EXPORT int onReceiveVideoPacket(NERtcMediaPacket* packet);

    /**
    * 就地加密音频数据（直接修改原数据）
    * @param packet 要加密的视频数据包
    * @return 0=成功, -1=失败
    */
    EXPORT int onSendAudioPacket(NERtcMediaPacket* packet);

    /**
    * 就地解密视频数据（直接修改原数据）
    * @param packet 要解密的视频数据包
    * @return 0=成功, -1=失败
    */
    EXPORT int onReceiveAudioPacket(NERtcMediaPacket* packet);

    #ifdef __cplusplus
    }
    #endif

    #endif // VIDEO_ENCRYPT_H 


    // "video_encrypt.cpp"
    #include "video_encrypt.h"
    #include <cstring>
    #include <cstdlib>

    // 对数据进行XOR加密/解密
    static void xor_encrypt_decrypt(unsigned char* data, long start, long end) {
        for (long i = start; i < end; i++) {
            data[i] ^= 0xff;
        }
    }

    // 实现导出的函数
    extern "C" {

    int onSendAudioPacket(NERtcMediaPacket* packet) {
        if (!packet || !packet->buffer || packet->size <= 0) {
            return -1;
        }

        // 将const转换为non-const（仅用于就地修改）
        unsigned char* data = const_cast<unsigned char*>(packet->buffer);
        // 所有数据 xor_encrypt_decrypt
        xor_encrypt_decrypt(data, 0, packet->size);
        return 0;
    }

    int onSendVideoPacket(NERtcMediaPacket* packet) {
        if (!packet || !packet->buffer || packet->size <= 0) {
            return -1;
        }

        // 将const转换为non-const（仅用于就地修改）
        unsigned char* data = const_cast<unsigned char*>(packet->buffer);
        // 所有数据 xor_encrypt_decrypt
        xor_encrypt_decrypt(data, 0, packet->size);
        return 0;
    }

    int onReceiveAudioPacket(NERtcMediaPacket* packet) {
        // 由于使用XOR加密，解密逻辑与加密相同
        return encrypt_video_data_inplace(packet);
    }

    int onReceiveVideoPacket(NERtcMediaPacket* packet) {
        // 由于使用XOR加密，解密逻辑与加密相同
        return encrypt_video_data_inplace(packet);
    }

    } // extern "C"     
    ```

2. **设置自定义加密配置**。


```TypeScript
import NEMeetingKit  from 'nemeeting-electron-sdk';

const neMeetingKit = NEMeetingKit.getInstance();
const meetingService = neMeetingKit.getMeetingService();

// 创建加密配置
const encryptionConfig = {
  encryptionMode: NEEncryptionMode.Custom,
  // 自定义加密逻辑的动态库路径，Windows 下为 .dll 文件，Mac 下为 .dylib 文件, linux 下为 .so 文件
  encryptLibPath: 'path/to/your/encrypt.dll',
};

// 设置加密配置到会议参数
const params = {
    displayName: '加密会议用户',
    encryptionConfig: encryptionConfig,
}
// 使用设置好的参数创建会议
meetingService.startMeeting(params).then(() => {
    // 创建会议成功
}).catch((error) => {
    // 创建会议失败
});
```