本文详细介绍如何使用网易会议组件 NEMeetingKit 配置会议媒体流加密功能。为保障会议内容安全，NEMeetingKit 提供内置加密和自定义加密两种媒体流加密方案。

## 前提条件

开始本文操作前，请确保您已经完成了 [登录鉴权](https://doc.yunxin.163.com/meeting/guide/DM0OTEwMjQ?platform=web)。

## 方案一：内置加密配置

NEMeetingKit 提供内置的媒体流加密功能，您可通过 [`NEMeetingParams.encryptionConfig`](https://doc.yunxin.163.com/meetingkit/references/web/typedoc/Latest/zh/interfaces/NEJoinMeetingParams.html#encryptionConfig) 进行配置，目前支持国密 SM4-ECB 算法。

:::note note
使用内置加密时，同一会议中的所有参会者必须配置相同的加解密密钥，否则将无法正常收发音视频。
:::

**示例代码**：

```javascript
const neMeetingKit = NEMeetingKit.getInstance();
const meetingService = neMeetingKit.getMeetingService();

// 创建加密配置
const encryptionConfig = {
  encryptionMode: NEEncryptionMode.GMCryptoSM4ECB,
  encryptKey: "yourEncryptionKey",
};
// 设置加密配置到会议参数
const params = {
    displayName: '加密会议用户',
    encryptionConfig: encryptionConfig,
}
// 使用设置好的参数创建会议
meetingService.startMeeting(params).then(() => {
    // 创建会议成功
}).catch((error) => {
    // 创建会议失败
});
```

## 方案二：自定义加密实现

对于需要更高安全级别的场景，NEMeetingKit 支持通过底层依赖的 [音视频通话 2.0 NERTC SDK](https://doc.yunxin.163.com/nertc/concept?platform=client) 实现自定义加密。您可以使用自己的加密算法对音频帧和视频帧进行加解密处理。

### 注意事项

- 本文示例中的加解密算法仅作示范，生产环境中请使用安全的加密算法。
- 详细的自定义加密实现请参考 NERTC SDK [流媒体加密 Web 版](https://doc.yunxin.163.com/nertc/guide/TE4MjYwMTU?platform=web)。
- 同一会议中所有参会者必须使用相同的加解密算法和密钥。

### 实现步骤

**监听 RTC 引擎初始化并进行加解密**。

自定义 `NEGlobalEventListener` 监听器，在 RTC 实例初始化完成后设置自定义加解密：

```javascript
const neMeetingKit = NEMeetingKit.getInstance();
    
neMeetingKit.addGlobalEventListener({
    beforeRtcEngineRelease(roomUuid, rtcWrapper) {
        console.log('beforeRtcEngineRelease', roomUuid)
        rtcWrapper.rtcEngine.client.off('sender-transform')
        rtcWrapper.rtcEngine.client.off('sender-transform')
    },
    beforeRtcEngineInitialize(roomUuid) {
        console.log('beforeRtcEngineInitialize', roomUuid)
    },
    afterRtcEngineInitialize(roomUuid, rtcWrapper) {
        console.log('afterRtcEngineInitialize', roomUuid, rtcWrapper)
        const client = rtcWrapper.rtcEngine.client
        if(!enableEncryption) {
          return
        }
        // 自定义加密回调
        client.on('sender-transform', ({mediaType, encodedFrame, controller}) => {
            if (encodedFrame.data.byteLength){
                // 进行自定义加密
            }
          controller.enqueue(encodedFrame);
        });
        // 自定义解密回调
        client.on('receiver-transform', ({mediaType, encodedFrame, controller}) => {
          if (encodedFrame.data.byteLength){
            // 进行自定义解密
          }
          controller.enqueue(encodedFrame);
        });
        // 3. 启用自定义加密
        client.enableCustomTransform()
      }
})
```