本文详细介绍如何在安卓平台上使用网易会议组件 NEMeetingKit 配置会议媒体流加密功能。为保障会议内容安全，NEMeetingKit 提供内置加密和自定义加密两种媒体流加密方案。

## 前提条件

开始本文操作前，请确保您已经完成了 [登录鉴权](https://doc.yunxin.163.com/meeting/guide/TAzNjk1MDc?platform=android) 的相关配置。

## 方案一：内置加密配置

NEMeetingKit 提供内置的媒体流加密功能，您可通过 [NEMeetingParams.encryptionConfig](https://doc.yunxin.163.com/meetingkit/references/android/dokka/Latest/zh/com/netease/yunxin/kit/meeting/sdk/NEMeetingParams.html#encryptionConfig) 进行配置，目前支持国密 SM4-ECB 算法。

:::note note
使用内置加密时，同一会议中的所有参会者必须配置相同的加解密密钥，否则将无法正常收发音视频。
:::

**示例代码如下：**

```Java
// 创建加密配置
NEEncryptionConfig encryptionConfig = new NEEncryptionConfig(
    NEEncryptionMode.GMCryptoSM4ECB, // 使用国密 SM4-ECB 算法
    "yourEncryptionKey"               // 16 字节的加密密钥
);

NEStartMeetingParams startParams = new NEStartMeetingParams();
// 设置加密配置到会议参数
startParams.encryptionConfig = encryptionConfig;
startParams.displayName = "加密会议用户";

// 使用设置好的参数开始会议
NEMeetingKit.getInstance().getMeetingService().startMeeting(context, startParams, callback);
```

## 方案二：自定义加密实现

对于需要更高安全级别的场景，NEMeetingKit 支持通过底层依赖的 [音视频通话 2.0 NERTC SDK](https://doc.yunxin.163.com/nertc/concept?platform=client) 实现自定义加密。您可以使用自己的加密算法对音频帧和视频帧进行加解密处理。

### 注意事项

- 本文示例中的加解密算法仅作示范，生产环境中请使用安全的加密算法。
- 详细的自定义加密实现请参考 NERTC SDK [流媒体加密](https://doc.yunxin.163.com/nertc/guide/DQwNjAzMDY?platform=android)。
- 同一会议中所有参会者必须使用相同的加解密算法和密钥。

### **实现步骤**

1. **添加依赖**。

    首先，需要为工程添加 NERTC SDK 和 NERoom 依赖。

    ```Groovy
    // app/build.gradle
    dependencies {
        compileOnly "com.netease.yunxin:nertc:$rtcVersion"
        compileOnly "com.netease.yunxin.kit.room:roomkit:$roomKitVersion"
    }
    ```

    ::: note note
    `rtcVersion` 和 `roomKitVersion` 的值应与您当前使用的网易会议组件版本兼容。您可在 [更新日志](https://doc.yunxin.163.com/meeting/guide/zk0MjM1OTg?platform=android) 中查看兼容版本信息。
    :::

2. **监听 RTC 引擎初始化**。

    自定义 `NEGlobalEventListener` 监听器，在 RTC 实例初始化完成后设置自定义加解密：

    ```Java
    // 1. 实现全局监听器
    public class CustomEncryptionListener extends NEGlobalEventListener {

        @Override
        public void beforeRtcEngineInitialize(String meetingNum, NERtcWrapper rtcWrapper) {
            // RTC 引擎初始化前的操作（如果需要）
        }

        @Override
        public void afterRtcEngineInitialize(String meetingNum, NERtcWrapper rtcWrapper) {
            // RTC 引擎初始化后，开启加密
            if (rtcWrapper != null && rtcWrapper.getRtcEngine() != null) {
                // 启用自定义加密
                rtcWrapper.getRtcEngine().enableEncryption(
                    true, // 开启加密
                    new NERtcEncryptionConfig(
                        // 加密类型设置为自定义
                        NERtcEncryptionConfig.EncryptionMode.EncryptionModeCustom,
                        // mode 选择内置加密时有效，自定义加密时设为 null
                        null,
                        // 自定义加密回调 observer, mode 为自定义加密时需要设置
                        new PacketObserver()
                    )
                );
            }
        }

        @Override
        public void beforeRtcEngineRelease(String meetingNum, NERtcWrapper rtcWrapper) {
            // RTC 引擎销毁前，可执行清理工作
            if (rtcWrapper != null && rtcWrapper.getRtcEngine() != null) {
                // 可选：关闭加密
                // rtcWrapper.getRtcEngine().enableEncryption(false, null);
            }
        }
    }

    // 2. 注册监听器（在 SDK 初始化完成后添加）
    NEGlobalEventListener encryptionListener = new CustomEncryptionListener();
    NEMeetingKit.getInstance().addGlobalEventListener(encryptionListener);
    ```

3. **实现自定义加解密逻辑**。

    实现 [`NERtcPacketObserver`](https://doc.yunxin.163.com/nertc/references/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1encryption_1_1_n_e_rtc_packet_observer.html) 接口，在音视频帧回调中处理数据：

    ```Java
    private class PacketObserver implements NERtcPacketObserver {
        // 控制开关，可根据需要动态调整
        private boolean enableAudioEncryption = true;
        private boolean enableVideoEncryption = true;

        @Override
        public boolean onSendAudioPacket(NERtcPacket neRtcPacket) {
            if (enableAudioEncryption) {
                // 发送音频帧前加密
                ByteBuffer buffer = neRtcPacket.getData();
                neRtcPacket.setData(encrypt(buffer, neRtcPacket.getSize()));
            }
            return true; // 返回 true 表示继续处理该数据包
        }

        @Override
        public boolean onSendVideoPacket(NERtcPacket neRtcPacket) {
            if (enableVideoEncryption) {
                // 发送视频帧前加密
                ByteBuffer buffer = neRtcPacket.getData();
                neRtcPacket.setData(encrypt(buffer, neRtcPacket.getSize()));
            }
            return true;
        }

        @Override
        public boolean onReceiveAudioPacket(NERtcPacket neRtcPacket) {
            if (enableAudioEncryption) {
                // 接收音频帧后解密
                ByteBuffer buffer = neRtcPacket.getData();
                neRtcPacket.setData(decrypt(buffer, neRtcPacket.getSize()));
            }
            return true;
        }

        @Override
        public boolean onReceiveVideoPacket(NERtcPacket neRtcPacket) {
            if (enableVideoEncryption) {
                // 接收视频帧后解密
                ByteBuffer buffer = neRtcPacket.getData();
                neRtcPacket.setData(decrypt(buffer, neRtcPacket.getSize()));
            }
            return true;
        }

        // 加密算法实现示例（仅作演示，生产环境请使用安全的加密算法）
        private ByteBuffer encrypt(ByteBuffer buffer, int size) {
            // 这里使用简单的位反转进行演示
            for (int i = 0; i < size; i++) {
                byte b = buffer.get(i);
                buffer.put(i, (byte) ~(b & 0xFF));
            }
            return buffer;
        }

        // 解密算法实现示例
        private ByteBuffer decrypt(ByteBuffer buffer, int size) {
            // 对应加密算法的解密实现
            for (int i = 0; i < size; i++) {
                byte b = buffer.get(i);
                buffer.put(i, (byte) ~(b & 0xFF));
            }
            return buffer;
        }
    }
    ```